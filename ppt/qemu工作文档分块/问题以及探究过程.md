# 问题探究过程

[toc]



## 实现指令翻译和捕捉

阅读intel手册，得到各个指令的二进制编码：

| 指令名称 | 二进制形式      |
| -------- | --------------- |
| UIRET    | 0xf3 0f 01 ec   |
| TESTUI   | 0xf3 0f 01 ed   |
| STUI     | 0xf3 0f 01 ef   |
| SENDUIPI | 0xf3 0f c7 /reg |
| CLUI     | 0xf3 0f 01 ee   |

找到x86指令翻译相关的代码：

```c
//target/i386/tcg/translate.c
//经过寻找,注意到f3是前缀标志位(4580行):
 /* Collect prefixes.  */ 
    switch (b) {
    case 0xf3:
        f3flag = true;  // 识别前缀,跳转到 4717行
        prefixes |= PREFIX_REPZ;
        goto next_byte;
//0f又会进行分支的再次跳转
reswitch:
    switch(b) {
    case 0x0f:
        /**************************/
        /* extended op code */
        b = x86_ldub_code(env, s) | 0x100;
        goto reswitch;

        /**************************/
        /* arith & logic */
        
//最后在相应分支下设置对应的指令捕捉代码
case 0x101:
        modrm = x86_ldub_code(env, s);
        switch (modrm) {
        case 0xee: /* rdpkru */
            if(prefixes & PREFIX_REPZ){
                printf("qemu:caught 0xf30fee CLUI\n");
                f3flag = false;
                break;
            }
            if (prefixes & PREFIX_LOCK) {
                goto illegal_op;
            }
            tcg_gen_trunc_tl_i32(s->tmp2_i32, cpu_regs[R_ECX]);
            gen_helper_rdpkru(s->tmp1_i64, cpu_env, s->tmp2_i32);
            tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], s->tmp1_i64);
            break;
        case 0xec:
            if (prefixes & PREFIX_REPZ){
                printf("qemu:caught 0xf30f01ec UIRET\n");
                f3flag = false;
            }
            break;
        case 0xed:
            if (prefixes & PREFIX_REPZ){
                printf("qemu:caught 0xf30f01ed TESTUI\n");
                f3flag = false;
            }
            break;
        case 0xef: /* wrpkru */
            if(prefixes & PREFIX_REPZ){
                printf("qemu:caught 0xf30f01ef STUI\n");
                f3flag = false;
                break;
            }
            if (prefixes & PREFIX_LOCK) {
                goto illegal_op;
            }
            tcg_gen_concat_tl_i64(s->tmp1_i64, cpu_regs[R_EAX],
                                  cpu_regs[R_EDX]);
            tcg_gen_trunc_tl_i32(s->tmp2_i32, cpu_regs[R_ECX]);
            gen_helper_wrpkru(cpu_env, s->tmp2_i32, s->tmp1_i64);
            break;
        }
case 0x1c7: /* cmpxchg8b */
        if(prefixes & PREFIX_REPZ){
            printf("qemu: caught 0xf30fc7 SENDUIPI\n");
            modrm = x86_ldub_code(env, s); // 此句加上以解决illegal instruction的问题
            break;
        }
```

### 



## 新的硬件状态设定

### 定位cpu状态

### cpu状态设定

```c++
//target/i386/cpu.h    CPUX86State
400行左右,msr编号定义
//target/i386/cpu.h/CPUArchState  1476 寄存器定义
```

#### 尝试寻找msr的读与写函数的位置

```c++
//target/i386/tcg/sysemu/misc_helper.c/helper_rdmsr 313
//target/i386/tcg/sysemu/misc_helper.c/helper_wrmsr 142
```

#### 增加对应的msr定义以及读写函数内容:

```c
//target/i386/cpu.h 258
#define CR4_UINTR_MASK (1U<<25)  // 软件使能控制位


//target/i386/cpu.h   404  mydefines msr 定义
#define MSR_IA32_UINTR_RR               0x985
#define MSR_IA32_UINTR_HANDLER          0x986
#define MSR_IA32_UINTR_STACKADJUST      0x987
#define MSR_IA32_UINTR_MISC             0x988
#define MSR_IA32_UINTR_PD               0x989
#define MSR_IA32_UINTR_TT               0x98a

// target/i386/cpu.h  CPUArchState 1565
uint64_t uintr_rr;
uint64_t uintr_handler;
uint64_t uintr_stackadjust;
uint64_t uintr_misc;
uint64_t uintr_pd;
uint64_t uintr_tt;
//target/i386/tcg/sysemu/misc_helper.c/helper_rdmsr 403
在文件头添加
#include "exec/log.h"
    case MSR_IA32_UINTR_RR:
        val = env->uintr_rr;
        if(Debug)qemu_log("qemu:rdmsr RR 0x%016lx\n",val);
        break;
    case MSR_IA32_UINTR_HANDLER:
        val = env->uintr_handler;
        qemu_log("qemu:rdmsr handler 0x%016lx\n",val);
        break;
    case MSR_IA32_UINTR_STACKADJUST:
        val = env->uintr_stackadjust;
        qemu_log("qemu:rdmsr stackadjust 0x%016lx\n",val);
        break;
    case MSR_IA32_UINTR_MISC:
        val = env->uintr_misc;
        qemu_log("qemu:rdmsr misc 0x%016lx eip: 0x%016lx\n",val,env->eip);
        break;
    case MSR_IA32_UINTR_PD:
        val = env->uintr_pd;
        qemu_log("qemu:rdmsr pd 0x%016lx\n",val);
        break;
    case MSR_IA32_UINTR_TT:
        val = env->uintr_tt;
        qemu_log("qemu:rdmsr tt 0x%016lx\n",val);
        break;
//target/i386/tcg/sysemu/misc_helper.c/helper_wrmsr   229
    case MSR_IA32_UINTR_RR:
        qemu_log("qemu:wrmsr RR 0x%lx\n",val);
        env->uintr_rr = val;
        if(val!= 0){ // 这里在后续实现逻辑时才添加
            if(Debug)qemu_log("getting rr not zero get into helper rr:%ld\n",val);
            helper_rrnzero(env);
        }
        break;
    case MSR_IA32_UINTR_HANDLER:
        qemu_log("qemu:wrmsr handler 0x%016lx\n",val);
        env->uintr_handler = val;
        break;
    case MSR_IA32_UINTR_STACKADJUST:
        qemu_log("qemu:wrmsr stackadjust 0x%lx\n",val);
        env->uintr_stackadjust = val;
        break;
    case MSR_IA32_UINTR_MISC:
        qemu_log("qemu:wrmsr misc 0x%016lx\n",val);
        env->uintr_misc = val;
        break;
    case MSR_IA32_UINTR_PD:
        qemu_log("qemu:wrmsr pd 0x%016lx\n",val);
        env->uintr_pd = val;
        break;
    case MSR_IA32_UINTR_TT:
        qemu_log("qemu:wrmsr tt 0x%016lx\n",val);
        env->uintr_tt = val;
        break;
```

### 指令模拟

研究一个具体的函数:

```c
gen_helper_rdtsc(cpu_env);  //target/i386/tcg/translate.c  7304
void helper_rdtsc(CPUX86State *env)  //target/i386/tcg/misc_helper.c  64
{
    helper_rdtsc(env);
    env->regs[R_ECX] = (uint32_t)(env->tsc_aux);
}
```

课件一个函数的helper函数的实现和调用关系符合以上的范式。

#### 尝试仿照验证函数定义和调用

```c
//target/i386/tcg/translate.c 5402 添加如下函数调用
gen_helper_senduipi(cpu_env, tcg_const_i32(uipi_index));
//target/i386/helper.h 35 添加如下宏定义
DEF_HELPER_2(senduipi, void ,env ,int)
//target/i386/tcg/misc_helper.c
void helper_senduipi(CPUX86State *env ,int uipi_index){
    if(Debug)printf("qemu:helper senduipi called receive %d index\n",uipi_index);
}
```

在打通后续的流程之后, 该函数确实可以被正确调用。



## 注意到定义新的硬件特性没有被识别

### 硬件向操作系统反馈feature

```shell
#arch/x86/kernel/uintr_fd.c/SYSCALL_DEFINE2(uintr_register_handler... 126
#修改部分 uintr 相关内核代码后，可以捕捉到对应的syscall确实被调用了，编译出的kernel输出如下：
[    6.608152] uintr_register_handler called
regeister returned 233
caught 0xf30fef STUI
create fd returned -1
Receiver enabled interrupts
Sender register error
```

```c
//以上对应的用户态代码如下(只放一部分)
int ret1 = uintr_register_handler(uintr_handler, 0);
	printf("regeister returned %d\n",ret1);
	ret = uintr_create_fd(0, 0);
	printf("create fd returned %d\n",ret);
	uintr_fd = ret;
	_stui();
	printf("Receiver enabled interrupts\n");
	if (pthread_create(&pt, NULL, &sender_thread, NULL)) {
		printf("Error creating sender thread\n");
		exit(EXIT_FAILURE);
	}
	/* Do some other work */
	while (!uintr_received)usleep(1);
	pthread_join(pt, NULL);
	close(uintr_fd);
	uintr_unregister_handler(0);
	printf("Success\n");
	exit(EXIT_SUCCESS);

//内核代码如下:
SYSCALL_DEFINE2(uintr_register_handler, u64 __user *, handler, unsigned int, flags)
{	
	if (Debug) printk("uintr_register_handler called\n");
	int ret;
	if (!uintr_arch_enabled())return 233;
		// return -EOPNOTSUPP;
	if (flags)return 234;
		// return -EINVAL;
	/* TODO: Validate the handler address */
	if (!handler) return 235;
		// return -EFAULT;
	ret = do_uintr_register_handler((u64)handler);
	pr_debug("recv: register handler task=%d flags %d handler %lx ret %d\n",
		 current->pid, flags, (unsigned long)handler, ret);
	return ret;
}
```

注意到返回的结果为233, 则查看对应的`uintr_arch_enabled`函数, 得到如下:

```c
inline bool uintr_arch_enabled(void){return static_cpu_has(X86_FEATURE_UINTR);}
```

发现无法再向下扩展函数, 查询`X86_FEATURE_UINTR`这个宏, 跳转到`arch/x86/include/asm/cpufeatures.h`其中存在大量的宏定义:

```c
#define X86_FEATURE_AVX512_4FMAPS	(18*32+ 3) /* AVX-512 Multiply Accumulation Single precision */
#define X86_FEATURE_FSRM		(18*32+ 4) /* Fast Short Rep Mov */
#define X86_FEATURE_UINTR		(18*32+ 5) /* User Interrupts support */
#define X86_FEATURE_AVX512_VP2INTERSECT (18*32+ 8) /* AVX-512 Intersect for D/Q */
#define X86_FEATURE_SRBDS_CTRL		(18*32+ 9) /* "" SRBDS mitigation MSR available */
```

经过和学长讨论, 尝试寻找和qemu之间的对应关系, 在qemu中尝试寻找`CPUID`相关的文件, 定位到`target/i386/cpu.h 600行左右`,有大量的定义。尝试寻找其中一个的对应关系`FPU`

```c
//qemu/target/i386/cpu.h  682
#define CPUID_EXT2_FPU     (1U << 0)
//linux/arch/x86/include/asm/cpufeatures.h  29
#define X86_FEATURE_FPU			( 0*32+ 0) /* Onboard FPU */
```

同时注意到, 这些feature有32为一组的分组特性, 尝试寻找uintr的对应关系, 并进行添加;

```c
//linux/arch/x86/include/asm/cpufeatures.h  380
#define X86_FEATURE_FSRM		(18*32+ 4) /* Fast Short Rep Mov */
#define X86_FEATURE_UINTR		(18*32+ 5) /* User Interrupts support */
//qemu/target/i386/cpu.h    860
/* Fast Short Rep Mov */
#define CPUID_7_0_EDX_FSRM              (1U << 4)
/* ？？？改cpuid uintr */
#define CPUID_7_0_EDX_UINTR              (1U << 5)
```

考虑到单纯定义未必会在qemu中体现, 可能需要有使用这个宏的地方, 开始继续寻找代码, 得到如下结果。

```c
//qemu/target/i386/cpu.c  4196
.features[FEAT_7_0_EDX] = CPUID_7_0_EDX_FSRM,
// 修改为
.features[FEAT_7_0_EDX] = CPUID_7_0_EDX_FSRM | CPUID_7_0_EDX_UINTR,
```

修改后编译qemu并执行，得到如下结果, 并无变化：

```shell
[  797.227827] uintr_register_handler called
regeister returned 233
create fd returned -1
Receiver enabled interrupts
Sender register error
```

为此在内核中测试FSRM是否是输出enable状态:

```c
// uintr内核代码	
if (!static_cpu_has(X86_FEATURE_FSRM)) {printk("FSRM not enabled\n");
}else{printk("FSRM enabled\n");}
if (!uintr_arch_enabled())return 233;
```

```shell
[    8.086769] uintr_register_handler called
[    8.087385] FSRM not enabled
regeister returned 233
caught 0xf30fef STUI
create fd returned -1
Receiver enabled interrupts
Sender register error
```

这说明qemu并没有未内核返回正确的信息位置，继续查看qemu代码，仔细阅读代码可知, 在cpu中列举了非常多的cpu芯片版本, 例如`EPYC-Milan`,`qemu64`,`phenom`等, 此处需要知道qemu具体编译出的cpu版本, 在对应的版本下添加cpu特性。

```shell
~/runlinux.sh > startlog.txt
grep CPU  startlog.txt # 得到以下关键信息
[    0.370356] smpboot: CPU0: AMD QEMU Virtual CPU version 2.5+ (family: 0xf, model: 0x6b, stepping: 0x1)
```

在`cpu.c`中搜索`QEMU Virtual CPU version`,定位到如下:

```c
.model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION, //1802 对应 qemu64
.model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION, //1931 对应 qemu32
.model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION, //2057 对应 athlon
```

在`qemu64`中添加后，验证未成功， 在`athlon`中添也未验证成功。

```c
.features[FEAT_7_0_EDX] = CPUID_7_0_EDX_UINTR,
```

继续查看源代码

查看linux启动时的日志输出，主要关注linux启动前的部分, 可见是TCG出现了问题

```shell
xxy@7af409e42583:~/qemu/build$ run > ~/startlog.txt  #写入log,防止大面积刷屏
qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.07H:EDX.fsrm [bit 4]
qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.07H:EDX [bit 5]
qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.07H:EDX.fsrm [bit 4]
qemu-system-x86_64: warning: TCG doesn't support requested feature: CPUID.07H:EDX [bit 5]
```

注释掉`cpu.c`中的下面这一句,再次查看输出

```c
.model_id = "QEMU Virtual CPU version " QEMU_HW_VERSION, //1802 对应 qemu64
//下面是shell命令
xxy@7af409e42583:~/qemu/build$ run > ~/startlog.txt  #写入log,防止大面积刷屏
```

没有相关输出, 说明cpu确实按照`qemu64`进行初始化, 接下来尝试寻找TCG支持相关的代码, 以及warning 发出的地方, 搜索`doesn't support requested feature`, 找到如下:

```c
//qemu/target/i386/cpu.c  6301
static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
if (verbose) {
        prefix = accel_uses_host_cpuid()
                 ? "host doesn't support requested feature"
                 : "TCG doesn't support requested feature？"; // 改
}
// 4347
static void mark_unavailable_features();
// 6153
void x86_cpu_expand_features(X86CPU *cpu, Error **errp);
```

通过插入输出,编译后再次执行得到如下结果:

```shell
qemu-system-x86_64: warning: expand featrue called
qemu-system-x86_64: warning: x86 cpu filter feature called
qemu-system-x86_64: warning: TCG doesn't support requested feature？: CPUID.07H:EDX.fsrm [bit 4]
qemu-system-x86_64: warning: TCG doesn't support requested feature？: CPUID.07H:EDX [bit 5]
qemu-system-x86_64: warning: expand featrue called
qemu-system-x86_64: warning: x86 cpu filter feature called
qemu-system-x86_64: warning: TCG doesn't support requested feature？: CPUID.07H:EDX.fsrm [bit 4]
qemu-system-x86_64: warning: TCG doesn't support requested feature？: CPUID.07H:EDX [bit 5]
```

再次寻找源代码，注意到如下函数：

```c
//qemu/target/i386/cpu.c  4989
uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
                                            bool migratable_only) // ？？？得到支持的featureword信息
FeatureWordInfo *wi = &feature_word_info[w];
uint64_t r = 0;
  if (kvm_enabled()) {
        if(Debug)warn_report("kvm enabled");
        switch (wi->type) {
        case CPUID_FEATURE_WORD:
///.....
        case MSR_FEATURE_WORD:
//.....
        }
    } else if (hvf_enabled()) {
        if(Debug)warn_report("hvf enabled");
//.......
    } else if (tcg_enabled()) {
  			if(Debug)warn_report("tcg enabled");
        r = wi->tcg_features;
    } else {
        return ~0;
    }
//进行输出定位后, 确认为r = wi->tcg_features; 这一行起主要作用,继续深入, 定位到一个巨大结构体中的位置
//qemu/target/i386/cpu.c  855
[FEAT_7_0_EDX] = {
        .type = CPUID_FEATURE_WORD,
        .feat_names = {
            NULL, NULL, "avx512-4vnniw", "avx512-4fmaps",
            "fsrm", "uintr", NULL, NULL,  // 改，加入feature info 信息
            "avx512-vp2intersect", NULL, "md-clear", NULL,
            NULL, NULL, "serialize", NULL,
            "tsx-ldtrk", NULL, NULL /* pconfig */, NULL,
            NULL, NULL, "amx-bf16", "avx512-fp16",
            "amx-tile", "amx-int8", "spec-ctrl", "stibp",
            NULL, "arch-capabilities", "core-capability", "ssbd",
        },
        .cpuid = {
            .eax = 7,
            .needs_ecx = true, .ecx = 0,
            .reg = R_EDX,
        },
        .tcg_features = TCG_7_0_EDX_FEATURES,  //这个宏,很关键
    },
// 进入展开的宏
//qemu/target/i386/cpu.c  666
#define TCG_7_0_EDX_FEATURES 0
// 修改后:
#define TCG_7_0_EDX_FEATURES (CPUID_7_0_EDX_UINTR)
```

#### 玄学问题:

以上操作完成后, linux依旧返回233, 但是在对linux做了以下理论上不会影响逻辑的修改后重新编译, 输出发生变化。

```c
//arch/x86/kernel/cpu/common.c  327
static __always_inline void setup_uintr(struct cpuinfo_x86 *c) // 初始化用户态中断,改？？？
{
	/* check the boot processor, plus compile options for UINTR. */
	if (!cpu_feature_enabled(X86_FEATURE_UINTR))
		printk("at setup uintr cpu featrue not enabled\n");
		goto disable_uintr;

	/* checks the current processor's cpuid bits: */
	if (!cpu_has(c, X86_FEATURE_UINTR))
		printk("at setup uintr cpu has not enabled\n");
		goto disable_uintr;

	/* Confirm XSAVE support for UINTR is present. */
	if (!cpu_has_xfeatures(XFEATURE_MASK_UINTR, NULL)) {
		printk("at setup uintr XSAVE not enabled\n");
		pr_info_once("x86: User Interrupts (UINTR) not enabled. XSAVE support for UINTR is missing.\n");
		goto clear_uintr_cap;
	}
```

```shell
# linux 内执行uipi_sample,输出如下:
/ # uipi_sample 
[    7.037078] uintr_register_handler called
[    7.038450] FSRM not enabled
wrmsr handler 
wrmsr pd 
wrmsr stackadjust 
rdmsr misc 
wrmsr misc 
# ..... rdmsr misc 若干
rdmsr misc 
regeister returned 0
rdmsr misc 
# ..... rdmsr misc 若干
create fd returned 3
rdmsr misc 
rdmsr misc 
rdmsr misc 
caught 0xf30fef STUI
rdmsr misc 
rdmsr misc 
Receiver enabled interrupts
rdmsr misc 
# ..... rdmsr misc 若干
wrmsr tt 
rdmsr misc 
rdmsr misc 
wrmsr misc 
rdmsr misc 
# ..... rdmsr misc 若干 
Sending IPI from sender thread
rdmsr misc 
# ..... rdmsr misc 若干 
[    7.085385] traps: uipi_sample[78] trap invalid opcode ip:401eb7 sp:7f44b1a09d90 error:0 in uipirdmsr misc 
_sample[401000+af000]
rdmsr misc 
# ..... rdmsr misc 若干
wrmsr misc 
wrmsr tt 
wrmsr pd 
wrmsr RR 
wrmsr stackadjust 
wrmsr handler 
[    7.112267] uipi_sample (77) used greatest stack depth: 14456 bytes left
rdmsr misc 
wrmsr misc 
wrmsr tt 
Illegal instruction
```

至此内核可以读取相关msr, 所以将内核代码修改的部分进行回调, 完善指令捕捉，完善信息输出，最后得到如下输入出: 

##### 值得思考

第一次执行：

```shell
/ # uipi_sample 
[    6.746036] uintr_register_handler called
qemu:wrmsr handler 0x0000000000401de5
qemu:wrmsr pd 0xffffa2ca438bc940
qemu:wrmsr stackadjust 0x0000000000000080
qemu:rdmsr misc 0x0000000000000000
qemu:wrmsr misc 0x000000ec00000000
[    6.747922] recv: register handler task=78 flags 0 handler 401de5 ret 0
qemu:rdmsr misc 0x000000ec00000000
#....
regeister returned 0qemu:rdmsr misc 0x000000ec00000000

qemu:rdmsr misc 0x000000ec00000000
#....
[    6.763195] uintr_create_fd called
[    6.765280] recv: Alloc vector success uintrfd 3 uvec 0 for task=78
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
create fd returned 3qemu:rdmsr misc 0x000000ec00000000

qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
qemu:caught 0xf30f01ef STUI
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
Receiver enabled interruptsqemu:rdmsr misc 0x000000ec00000000

qemu:rdmsr misc 0x000000ec00000000
#.....
[    6.789114] uintr_register_sender called
qemu:wrmsr tt 0xffffa2ca418b0001
qemu:rdmsr misc 0x0000000000000000
qemu:wrmsr misc 0x0000000000000100
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
[    6.792473] send: register sender task=79 flags 0 ret(uipi_id)=0
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
Sending IPI from sender thread
qemu:rdmsr misc 0x000000ec00000000
qemu: caught 0xf30fc7 SENDUIPI
qemu:rdmsr misc 0x000000ec00000000
#.....
[    6.798139] traps: uipi_sample[79] trap invalid opcode ip:401eba sp:7ff7c490ed90 error:0 in uipi_sample[401000+af000]
qemu:rdmsr misc 0x000000ec00000000
#......
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr tt 0x0000000000000000
qemu:wrmsr pd 0x0000000000000000
qemu:wrmsr RR 0x0000000000000000
qemu:wrmsr stackadjust 0x0000000000000000
qemu:wrmsr handler 0x0000000000000000
[    6.813875] recv: Release uintrfd for r_task 78 uvec 0
qemu:rdmsr misc 0x0000000000000100
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr tt 0x0000000000000000
```

第二次执行：

```shell
/ # uipi_sample 
[   38.183970] uintr_register_handler called
qemu:wrmsr handler 0x0000000000401de5
qemu:wrmsr pd 0xffffa2ca438bc9c0
qemu:wrmsr stackadjust 0x0000000000000080
qemu:rdmsr misc 0x0000000000000000
qemu:wrmsr misc 0x000000ec00000000
[   38.184359] recv: register handler task=80 flags 0 handler 401de5 ret 0
qemu:rdmsr misc 0x000000ec00000000
#.....
regeister returned 0qemu:rdmsr misc 0x000000ec00000000

qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
[   38.186027] uintr_create_fd called
[   38.186255] recv: Alloc vector success uintrfd 3 uvec 0 for task=80
qemu:rdmsr misc 0x000000ec00000000
create fd returned 3qemu:rdmsr misc 0x000000ec00000000

qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
Receiver enabled interruptsqemu:rdmsr misc 0x000000ec00000000

qemu:rdmsr misc 0x000000ec00000000
#.....
[   38.190652] uintr_register_sender called
qemu:rdmsr misc 0x000000ec00000000
qemu:wrmsr tt 0xffffa2ca418b0001
qemu:rdmsr misc 0x0000000000000000
qemu:wrmsr misc 0x0000000000000100
[   38.191610] send: registeqemu:rdmsr misc 0x000000ec00000000
r sender task=81 flags 0 ret(uipi_id)=0
qemu:rdmsr misc 0x000000ec00000000
Sending IPI from sender thread
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
[   38.193956] traps: uipi_sample[81] trap invalid opcode ip:401eba sp:7f845374fd90 error:0 in uipi_sample[401000+af000]
qemu:rdmsr misc 0x000000ec00000000
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr tt 0x0000000000000000
qemu:wrmsr pd 0x0000000000000000
qemu:wrmsr RR 0x0000000000000000
qemu:wrmsr stackadjust 0x0000000000000000
qemu:wrmsr handler 0x0000000000000000
[   38.202607] recv: Release uintrfd for r_task 80 uvec 0
qemu:rdmsr misc 0x0000000000000100
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr tt 0x0000000000000000
Illegal instruction
```

注意到以上两者的区别，这个很奇怪。

注意到，在捕捉SENDUIPI时，没有将指令的最后一位，即最后一位寄存器表示的字节入读，导致后续出现非法指令报错，修改捕捉SENDUIPI的的代码如下。

```c
case 0x1c7: /* cmpxchg8b */
        if(prefixes & PREFIX_REPZ){
            printf("qemu: caught 0xf30fc7 SENDUIPI\n");
            modrm = x86_ldub_code(env, s); // 此句加上以解决illegal instruction的问题
            break;
        }
```

修改`uipi_sample.c`,使得最后不再死循环等待，随后的运行代码如下：

```shell
/ # uipi_sample 
[    9.059653] uintr_register_handler called
qemu:wrmsr handler 0x0000000000401de5
qemu:wrmsr pd 0xffff9fa5039233c0
qemu:wrmsr stackadjust 0x0000000000000080
qemu:rdmsr misc 0x0000000000000000
qemu:wrmsr misc 0x000000ec00000000
[    9.062016] recv: register handler task=78 flags 0 handler 401de5 ret 0
qemu:rdmsr misc 0x000000ec00000000
#......
regeister returned 0qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
#......
[    9.075342] uintr_create_fd called
[    9.077466] recv: Alloc vector success uintrfd 3 uvec 0 for task=78
qemu:rdmsr misc 0x000000ec00000000
create fd returned 3qemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000
#...
qemu:caught 0xf30f01ef STUI
qemu:rdmsr misc 0x000000ec00000000
Receiver enabled interruptsqemu:rdmsr misc 0x000000ec00000000
qemu:rdmsr misc 0x000000ec00000000

qemu:rdmsr misc 0x000000ec00000000
#....
[    9.097662]qemu:rdmsr misc 0x000000ec00000000
 uintr_register_sender called
qemu:wrmsr tt 0xffff9fa5018cf001
qemu:rdmsr misc 0x0000000000000000
qemu:wrmsr misc 0x0000000000000100
[    9.104338] send: register sender task=79 flags 0 ret(uipi_id)=0
Sending IPI from sender thread index:0 
qemu: caught 0xf30fc7 SENDUIPI
qemu:helper senduipi called receive  regidx:240, uipiindex: 0
[    9.106657] uintr_unregister_sender called
[    9.108545] send: unregister sender uintrfd 3 for task=79 ret 0
qemu:rdmsr misc 0x0000000000000100
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr tt 0x0000000000000000
qemu:rdmsr misc 0x000000ec00000000
#......
[    9.127159] recv: Release uintrfd for r_task 78 uvec 0
qemu:rdmsr misc 0x000000ec00000000
[    9.129770] uintr_unregister_handler called
qemu:rdmsr misc 0x000000ec00000000
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr pd 0x0000000000000000
qemu:wrmsr RR 0x0000000000000000
qemu:wrmsr stackadjust 0x0000000000000000
qemu:wrmsr handler 0x0000000000000000
[    9.132581] recv: unregister handler task=78 flags 0 ret 0
Success
```





## 实现内存读写

qemu中有大量的内存读写指令函数, 但是其具体的作用机制并不清晰, 查询的是物理地址还是虚拟地址也没有说明。在实现内存读写的过程中, 由于senduipi是在用户态执行的指令, 但是直接仿照其他指令访问内核维护的地址, 会触发异常。一个办法是提权, 另一个办法是硬件进行查页表, 经过多次的尝试, 我们最终找到了硬件查页表的方法, 并成功访问了对应的地址。

以下是一些失败的尝试:

```c
//失败的方法
void helper_senduipi(CPUX86State *env ,int reg_index){
    int uipi_index = env->regs[R_EAX];
    if(Debug)printf("qemu:helper senduipi called receive  regidx:%d, uipiindex: %d\n",reg_index,uipi_index);
    uint64_t content = cpu_ldq_data_ra(env, (env->uintr_tt>>3)<<3,0);
    if(Debug)printf("data of uitt0is 0x%016lx\n",content);
}
/* 操作系统报错
qemu:helper senduipi called receive  regidx:240, uipiindex: 0
 IPI from sender thread index:0 
[   29.290347] uipi_sample[79]: segfault at ffff9315c3951000 ip 0000000000401eb4 sp 00007f9cba791d90 error 5 in uipi_sample[401000+af000]
[   29.293130] Code: 89 c7 e8 ff 18 02 00 bf 01 00 00 00 e8 75 91 01 00 8b 45 f4 89 c6 48 8d 05 81 e1 0a 00 48 89 c7 b8 00 00 00 00 e8 1c 9c 01 00 <8b> 45 f4 48 98 48 89 45 f8 48 8b 45 f8 f3 0f c7 f0 90 8b 05 08 e5
qemu:wrmsr misc 0x0000000000000000
*/


TCGv t0;
t0 = tcg_temp_local_new();
t0 = (TCGv)env->uintr_tt; // 将t0修改为地址
if(Debug){printf("debug: before t0: %llx   A0: %llx\n",(long long unsigned)t0,(long long unsigned)s->A0);}
gen_op_ld_v(s, ot, t0, s->A0);
if(Debug){printf("debug: after  t0: %llx   A0: %llx\n",(long long unsigned)t0,(long long unsigned)s->A0);}
tcg_temp_free(t0);
/*
debug: before t0: ffff901883890001   A0: bf8
qemu-system-x86_64: /home/xxy/qemu/include/tcg/tcg.h:657: temp_idx: Assertion `n >= 0 && n < tcg_ctx->nb_temps' failed.
/home/xxy/runlinux.sh: line 5: 82338 Aborted                 (core dumped) /home/xxy/qemu/build/x86_64-softmmu/qemu-system-x86_64 

debug: before t0: ed0   A0: ffff8cf9838c0001
qemu-system-x86_64: /home/xxy/qemu/include/tcg/tcg.h:657: temp_idx: Assertion `n >= 0 && n < tcg_ctx->nb_temps' failed.
/home/xxy/runlinux.sh: line 5: 83796 Aborted  

*/


void helper_senduipi(CPUX86State *env ,int reg_index){
    CPUState *cs = env_cpu(env);
    int uipi_index = env->regs[R_EAX];
    if(Debug)printf("qemu:helper senduipi called receive  regidx:%d, uipiindex: %d\n",reg_index,uipi_index);
    uint64_t content = x86_ldq_phys(cs,(env->uintr_tt>>3)<<3);
    // uint64_t content = cpu_ldq_data_ra(env, (env->uintr_tt>>3)<<3,0);
    if(Debug)printf("data of uitt0is 0x%016lx\n",content);
}
读取了错误的数据
/*
qemu:helper senduipi called receive  regidx:240, uipiindex: 0
data of uitt0is 0x0000000000000000
*/
                 

其他的方法也都失败了
printf("qemu: caught 0xf30fc7 SENDUIPI\n "); // 改 Debug
uint64_t content;
cpu_physical_memory_rw(env->uintr_tt,&content,8,false);
if(Debug) printf("    xxx               %lx \n", content);

/*qemu: caught 0xf30fc7 SENDUIPI
                    0 
qemu:helper senduipi called receive  regidx:240, uipiindex: 0 */

cpu_ldq_mmuidx_ra(env, addr, mem_idx, GETPC()); 
// uint64_t content = x86_ldq_phys(cs,uitt_phyaddress + (uitte_index<<4));
// uint64_t upidaddress = x86_ldq_phys(cs, uitt_phyaddress + (uitte_index<<4) + 8);
```

正确的方法如下, 其中核心的方法是找到了并重写了用于将虚拟地址转换为物理地址的方法。得到物理地址后, `cpu_physical_memory_rw`函数可以正确地读写内存。

```c
//正确的方法：
    // read tempUITTE from 16 bytes at UITTADDR+ (reg « 4);
    uint64_t uitt_phyaddress = get_hphys2(cs, (env->uintr_tt>>3)<<3 , MMU_DATA_LOAD, &prot);
    if(Debug) printf("qemu: uitt_phyaddress %lx \n", uitt_phyaddress);
    struct uintr_uitt_entry uitte;
    cpu_physical_memory_rw(uitt_phyaddress + (uitte_index<<4), &uitte, 16,false);
    if(Debug)printf("qemu: data of uitt valid:%d user_vec:%d \n",uitte.valid, uitte.user_vec);
    if(Debug)printf("qemu: UPID address 0x%016lx\n", uitte.target_upid_addr);
    // read tempUPID from 16 bytes at tempUITTE.UPIDADDR;// under lock
    uint64_t upid_phyaddress = get_hphys2(cs, uitte.target_upid_addr, MMU_DATA_LOAD, &prot);
    struct uintr_upid upid;
    cpu_physical_memory_rw(upid_phyaddress, &upid, 16, false);
    if(Debug)printf("qemu: content of upid:  status:0x%x    nv:0x%x    ndst:0x%x    0x%016lx\n", upid.nc.status, upid.nc.nv, upid.nc.ndst, upid.puir);
    // tempUPID.PIR[tempUITTE.UV] := 1;
    upid.puir |= 1<<uitte.user_vec;
    //IF tempUPID.SN = tempUPID.ON = 0
    if(upid.nc.status == 0){
    //THEN  tempUPID.ON := 1;   sendNotify := 1;
        upid.nc.status |= UPID_ON;
    }else{ // ELSE sendNotify := 0;

    }
    //write tempUPID to 16 bytes at tempUITTE.UPIDADDR;// release lock
```

在逻辑实现方面, 如果不修改upid.puir, 得到如下输出

```shell
emu: caught 0xf30fc7 SENDUIPI
 qemu:helper senduipi called receive  regidx:240, uipiindex: 0
mmu_translate ret: -1
qemu: uitt_phyaddress 290d000 
qemu: data of uitt valid:1 user_vec:0 
qemu: UPID address 0xffff9e3682a11840
mmu_translate ret: -1
qemu: content of upid:  status:0x0    nv:0xec    ndst:0x100    0x0000000000000000
qemu: data write back in upid:  status:0x1    nv:0xec    ndst:0x100    0x0000000000000000
[    5.551340] uintr_unregister_sender called
[    5.552576] send: unregister sender uintrfd 3 for task=78 ret 0
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr tt 0x0000000000000000
Sending IPI from sender thread index:0 
[    5.563810] recv: Release uintrfd for r_task 77 uvec 0
[    5.567603] uintr_unregister_handler called
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr pd 0x0000000000000000
qemu:wrmsr RR 0x0
qemu:wrmsr stackadjust 0x0
qemu:wrmsr handler 0x0000000000000000
[    5.571613] recv: unregister handler task=77 flags 0 ret 0
Success
```

如果修改upid.puir, 则用户程序不会执行结束. 这和linux内核实现有关, 我们之后讨论:

```shell
ending IPI from sender thread index:0 
qemu: caught 0xf30fc7 SENDUIPI
 qemu:helper senduipi called receive  regidx:240, uipiindex: 0
mmu_translate ret: -1
qemu: uitt_phyaddress 2a3b000 
qemu: data of uitt valid:1 user_vec:0 
qemu: UPID address 0xffff9bfac293fd00
mmu_translate ret: -1
qemu: content of upid: status:0x0    nv:0xec    ndst:0x0    0x0000000000000000
qemu: data write back in upid:  status:0x1    nv:0xec    ndst:0x0    0x0000000000000001
[    9.319021] uintr_unregister_sender called
[    9.322055] send: unregister sender uintrfd 3 for task=79 ret 0
qemu:wrmsr misc 0x0000000000000000
qemu:wrmsr tt 0x0000000000000000
# 随后一直在读 rdmsr misc 0x000000ec00000000
```





## 中断的定位

### 找到中断逻辑部分,添加pins

```c
bool x86_cpu_exec_interrupt(CPUState *cs, int interrupt_request)  //???？？？中断相关，接收方了已经是
{
    X86CPU *cpu = X86_CPU(cs);
    CPUX86State *env = &cpu->env;
    int intno;

    interrupt_request = x86_cpu_pending_interrupt(cs, interrupt_request);
    if (!interrupt_request) {
        return false;
    }
    /* Don't process multiple interrupt requests in a single call.
     * This is required to make icount-driven execution deterministic.
     */
    switch (interrupt_request) {
    case CPU_INTERRUPT_POLL:
        cs->interrupt_request &= ~CPU_INTERRUPT_POLL;
        apic_poll_irq(cpu->apic_state);
        break;
    case CPU_INTERRUPT_SIPI:
        if(Debug) printf("x86 cpu exec interrupt called sipi \n");
        do_cpu_sipi(cpu);
        break;
    case CPU_INTERRUPT_SMI:
        cpu_svm_check_intercept_param(env, SVM_EXIT_SMI, 0, 0);
        cs->interrupt_request &= ~CPU_INTERRUPT_SMI;
        do_smm_enter(cpu);
        break;
    case CPU_INTERRUPT_NMI:
        cpu_svm_check_intercept_param(env, SVM_EXIT_NMI, 0, 0);
        cs->interrupt_request &= ~CPU_INTERRUPT_NMI;
        env->hflags2 |= HF2_NMI_MASK;
        do_interrupt_x86_hardirq(env, EXCP02_NMI, 1);
        break;
    case CPU_INTERRUPT_MCE:
        cs->interrupt_request &= ~CPU_INTERRUPT_MCE;
        do_interrupt_x86_hardirq(env, EXCP12_MCHK, 0);
        break;
    case CPU_INTERRUPT_HARD:
        
        cpu_svm_check_intercept_param(env, SVM_EXIT_INTR, 0, 0);
        cs->interrupt_request &= ~(CPU_INTERRUPT_HARD |
                                   CPU_INTERRUPT_VIRQ);
        intno = cpu_get_pic_interrupt(env);
        if(Debug )printf("!!! interrupt %d  intno:%d \n",interrupt_request, intno); //改 后面为了过滤,添加了  Debug && intno == 0xec
        qemu_log_mask(CPU_LOG_INT,
                      "Servicing hardware INT=0x%02x\n", intno);
        do_interrupt_x86_hardirq(env, intno, 1);
        break;
    case CPU_INTERRUPT_VIRQ:
        cpu_svm_check_intercept_param(env, SVM_EXIT_VINTR, 0, 0);
        intno = x86_ldl_phys(cs, env->vm_vmcb
                             + offsetof(struct vmcb, control.int_vector));
        qemu_log_mask(CPU_LOG_INT,
                      "Servicing virtual hardware INT=0x%02x\n", intno);
        do_interrupt_x86_hardirq(env, intno, 1);
        cs->interrupt_request &= ~CPU_INTERRUPT_VIRQ;
        env->int_ctl &= ~V_IRQ_MASK;
        break;
    }

    /* Ensure that no TB jump will be modified as the program flow was changed.  */
    return true;
}

void do_interrupt_all(X86CPU *cpu, int intno, int is_int,
                      int error_code, target_ulong next_eip, int is_hw) // 接收方执行中断？
{
    CPUX86State *env = &cpu->env;

    if (qemu_loglevel_mask(CPU_LOG_INT)) {
        if ((env->cr[0] & CR0_PE_MASK)) {
            static int count;

            qemu_log("%6d: v=%02x e=%04x i=%d cpl=%d IP=%04x:" TARGET_FMT_lx
                     " pc=" TARGET_FMT_lx " SP=%04x:" TARGET_FMT_lx,
                     count, intno, error_code, is_int,
                     env->hflags & HF_CPL_MASK,
                     env->segs[R_CS].selector, env->eip,
                     (int)env->segs[R_CS].base + env->eip,
                     env->segs[R_SS].selector, env->regs[R_ESP]);
            if (intno == 0x0e) {
                qemu_log(" CR2=" TARGET_FMT_lx, env->cr[2]);
            } else {
                qemu_log(" env->regs[R_EAX]=" TARGET_FMT_lx, env->regs[R_EAX]);
            }
            qemu_log("\n");
            log_cpu_state(CPU(cpu), CPU_DUMP_CCOP);
#if 0
            {
                int i;
                target_ulong ptr;

                qemu_log("       code=");
                ptr = env->segs[R_CS].base + env->eip;
                for (i = 0; i < 16; i++) {
                    qemu_log(" %02x", ldub(ptr + i));
                }
                qemu_log("\n");
            }
#endif
            count++;
        }
    }
    if (env->cr[0] & CR0_PE_MASK) { // 改， 中断具体分发，应该不涉及user only
#if !defined(CONFIG_USER_ONLY)
        if (env->hflags & HF_GUEST_MASK) {
            printf("HF_GUEST_MASK even \n");
            handle_even_inj(env, intno, is_int, error_code, is_hw, 0);
        }
#endif
#ifdef TARGET_X86_64
        if (env->hflags & HF_LMA_MASK) {
            printf("HF_LMA_MASK 64 \n");
            do_interrupt64(env, intno, is_int, error_code, next_eip, is_hw);
        } else
#endif
        {   
            printf("interrupt protected \n");
            do_interrupt_protected(env, intno, is_int, error_code, next_eip,
                                   is_hw);
        }
    } else {
#if !defined(CONFIG_USER_ONLY)
        if (env->hflags & HF_GUEST_MASK) {
            printf("HF_GUEST_MASK even inj \n");
            handle_even_inj(env, intno, is_int, error_code, is_hw, 1);
        }
#endif  
        printf("do real \n");
        do_interrupt_real(env, intno, is_int, error_code, next_eip);
    }

#if !defined(CONFIG_USER_ONLY)
    if (env->hflags & HF_GUEST_MASK) {
        printf("HF_GUEST_MASK do real \n");
        CPUState *cs = CPU(cpu);
        uint32_t event_inj = x86_ldl_phys(cs, env->vm_vmcb +
                                      offsetof(struct vmcb,
                                               control.event_inj));

        x86_stl_phys(cs,
                 env->vm_vmcb + offsetof(struct vmcb, control.event_inj),
                 event_inj & ~SVM_EVTINJ_VALID);
    }
#endif
}
```

```shell
#对应输出
qemu:rdmsr misc 0x000000ec00000000
!!! interrupt 2  intno:236 
HF_LMA_MASK 64 
!!! interrupt 2  intno:234 
HF_LMA_MASK 64 
[   37.623955] rdmsrl 5
qemu:rdmsr misc 0x000000ec00000000
!!! interrupt 2  intno:236 
HF_LMA_MASK 64 
[   37.623955] rdmsrl 5
qemu:rdmsr misc 0x000000ec00000000
!!! interrupt 2  intno:236 
HF_LMA_MASK 64 
[ !!! interrupt 2  intno:234 
HF_LMA_MASK 64 
  37.623955] rdmsrl 5
qemu:rdmsr misc 0x000000ec00000000
!!! interrupt 2  intno:236 
HF_LMA_MASK 64 
[   !!! interrupt 2  intno:234 
HF_LMA_MASK 64 
```

查询手册和linux源代码可知，进入死循环的原因是因为将`upid.puir`置为1后, 操作检测到, 会给自己发一个中断, 而对应用户态中断的UIVX恰好为236。至此我们定位到我们需要修改的中断处理函数为`do_interrupt64`。



## 指令相关的硬件逻辑实现







### APIC相关

```c
//target/i386/helper.c  中有apic相关的函数, 其中do_cpu_sipi可能和核间中断有关。

void do_cpu_sipi(X86CPU *cpu)
{
    apic_sipi(cpu->apic_state);
}

//hw/apic/apic.c
void apic_sipi(DeviceState *dev)
{   
    if(Debug)printf("qemu: apic sipi called\n");
    APICCommonState *s = APIC(dev);
    cpu_reset_interrupt(CPU(s->cpu), CPU_INTERRUPT_SIPI);
    if (!s->wait_for_sipi)
        return;
    cpu_x86_load_seg_cache_sipi(s->cpu, s->sipi_vector);
    s->wait_for_sipi = 0;
}

static void apic_mem_write(void *opaque, hwaddr addr, uint64_t val, ) //注意到时静态函数, 所以如果要考虑清除eoi, 可能要另外写函数。
```







## Xsave 相关实现

搜索xsave, 找到如下引用:

```c
//target/i386/cpu.h
#define XSTATE_FP_BIT                   0
#define XSTATE_SSE_BIT                  1
#define XSTATE_YMM_BIT                  2
#define XSTATE_BNDREGS_BIT              3
#define XSTATE_BNDCSR_BIT               4
#define XSTATE_OPMASK_BIT               5
#define XSTATE_ZMM_Hi256_BIT            6
#define XSTATE_Hi16_ZMM_BIT             7
#define XSTATE_PKRU_BIT                 9
#define XSTATE_UINTR_BIT                14
//改 XSTAVE 根据手册,添加对应的bitmap标识
#define XSTATE_XTILE_CFG_BIT            17
#define XSTATE_XTILE_DATA_BIT           18
#define XSTATE_UINTR_MASK               (1ULL << XSTATE_UINTR_BIT)
#define XSTATE_FP_MASK                  (1ULL << XSTATE_FP_BIT)
#define XSTATE_SSE_MASK                 (1ULL << XSTATE_SSE_BIT)
#define XSTATE_YMM_MASK                 (1ULL << XSTATE_YMM_BIT)
#define XSTATE_BNDREGS_MASK             (1ULL << XSTATE_BNDREGS_BIT)
#define XSTATE_BNDCSR_MASK              (1ULL << XSTATE_BNDCSR_BIT)
#define XSTATE_OPMASK_MASK              (1ULL << XSTATE_OPMASK_BIT)
#define XSTATE_ZMM_Hi256_MASK           (1ULL << XSTATE_ZMM_Hi256_BIT)
#define XSTATE_Hi16_ZMM_MASK            (1ULL << XSTATE_Hi16_ZMM_BIT)
#define XSTATE_PKRU_MASK                (1ULL << XSTATE_PKRU_BIT)
#define XSTATE_XTILE_CFG_MASK           (1ULL << XSTATE_XTILE_CFG_BIT)
#define XSTATE_XTILE_DATA_MASK          (1ULL << XSTATE_XTILE_DATA_BIT)

//target/i386/tcg/fpuhelper.c
static bool Debug = true;
static void do_xsave(CPUX86State *env, target_ulong ptr, uint64_t rfbm,
                     uint64_t inuse, uint64_t opt, uintptr_t ra)
{
    uint64_t old_bv, new_bv;
    if(Debug)printf("do xsave called\n"); // 改 xsave
    /* The OS must have enabled XSAVE.  */
    if (!(env->cr[4] & CR4_OSXSAVE_MASK)) {
        raise_exception_ra(env, EXCP06_ILLOP, ra);
    }

    /* The operand must be 64 byte aligned.  */
    if (ptr & 63) {
        raise_exception_ra(env, EXCP0D_GPF, ra);
    }
    /* Never save anything not enabled by XCR0.  */
    rfbm &= env->xcr0;
    opt &= rfbm;
    if (opt & XSTATE_FP_MASK) {
        do_xsave_fpu(env, ptr, ra);
    }
    if (rfbm & XSTATE_SSE_MASK) {
        /* Note that saving MXCSR is not suppressed by XSAVEOPT.  */
        do_xsave_mxcsr(env, ptr, ra);
    }
    if (opt & XSTATE_SSE_MASK) {
        do_xsave_sse(env, ptr, ra);
    }
    if (opt & XSTATE_BNDREGS_MASK) {
        do_xsave_bndregs(env, ptr + XO(bndreg_state), ra);
    }
    if (opt & XSTATE_BNDCSR_MASK) {
        do_xsave_bndcsr(env, ptr + XO(bndcsr_state), ra);
    }
    if (opt & XSTATE_PKRU_MASK) {
        do_xsave_pkru(env, ptr + XO(pkru_state), ra);
    }
    if (opt & XSTATE_UINTR_MASK) {// 改 
        do_xsave_uintr(env, ptr , ra);
    }

    /* Update the XSTATE_BV field.  */
    old_bv = cpu_ldq_data_ra(env, ptr + XO(header.xstate_bv), ra);
    new_bv = (old_bv & ~rfbm) | (inuse & rfbm);
    cpu_stq_data_ra(env, ptr + XO(header.xstate_bv), new_bv, ra);
}

/*
在这里介绍一下一个宏展开
#define XO(X)  offsetof(X86XSaveArea, X)
#define offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)
__builtin_offsetof 的作用是什么?
这里使用的是一个利用编译器技术的小技巧，即先求得结构成员变量在结构体中的相对于结构体的首地址的偏移地址，然后根据结构体的首地址为0，从而得出该偏移地址就是该结构体变量在该结构体中的偏移，即：该结构体成员变量距离结构体首的距离。
*/

static void do_xsave_uintr(CPUX86State *env, target_ulong ptr, uintptr_t ra){ //改
    cpu_stq_data_ra(env, ptr, env->uintr_handler, ra);
    cpu_stq_data_ra(env, ptr+8, env->uintr_stackadjust, ra);
    cpu_stq_data_ra(env, ptr+16, env->uintr_misc, ra);
    cpu_stq_data_ra(env, ptr+24, env->uintr_pd, ra);
    cpu_stq_data_ra(env, ptr+32, env->uintr_rr, ra);
    cpu_stq_data_ra(env, ptr+40, env->uintr_tt, ra);
}

static void do_xrstor_uintr(CPUX86State *env, target_ulong ptr, uintptr_t ra){ //改
    env->uintr_handler = cpu_ldq_data_ra(env, ptr, ra);
    env->uintr_stackadjust = cpu_ldq_data_ra(env, ptr+8, ra);
    env->uintr_misc = cpu_ldq_data_ra(env, ptr+16, ra);
    env->uintr_pd = cpu_ldq_data_ra(env, ptr+24, ra);
    env->uintr_rr = cpu_ldq_data_ra(env, ptr+32, ra);
    env->uintr_tt = cpu_ldq_data_ra(env, ptr+40, ra);
}

static void clear_uintr_reg(CPUX86State *env){ // 改
    env->uintr_handler=0;
    env->uintr_stackadjust=0;
    env->uintr_misc=0;
    env->uintr_pd=0;
    env->uintr_rr=0;
    env->uintr_tt=0;
}

//在helper_xrstor中添加如下
	if (rfbm & XSTATE_UINTR_MASK){ // 改
        if (xstate_bv & XSTATE_UINTR_MASK) {
            do_xrstor_uintr(env, ptr + XO(uintr_state), ra);
        } else {
            clear_uintr_reg(env);
        }
  }

//target/i386/tcg/tcg-cpu.h
typedef struct X86XSaveArea {
    X86LegacyXSaveArea legacy;
    X86XSaveHeader header;

    /* Extended save areas: startoffset:0x240 */

    /* AVX State: */
    XSaveAVX avx_state;

    /* Ensure that XSaveBNDREG is properly aligned. */
    uint8_t padding[XSAVE_BNDREG_OFFSET
                    - sizeof(X86LegacyXSaveArea)
                    - sizeof(X86XSaveHeader)
                    - sizeof(XSaveAVX)];
    /* MPX State: */
    XSaveBNDREG bndreg_state;
    XSaveBNDCSR bndcsr_state;
    /* AVX-512 State: */
    XSaveOpmask opmask_state;
    XSaveZMM_Hi256 zmm_hi256_state;
    XSaveHi16_ZMM hi16_zmm_state;
    /* PKRU State: */
    XSavePKRU pkru_state;
    XSaveUINTR uintr_state; // 改
} X86XSaveArea;


//target/i386/cpu.h 添加如下区域
/* Ext. save area 14: UINTR state*/ 
typedef struct XSaveUINTR {
    uint64_t handler;
    uint64_t stack_adjust;
    struct{
        uint32_t uittsz;
        uint8_t uinv;
        uint16_t reserved;
        uint8_t uif; // bit7 is the uif
    };
    uint64_t upidaddr;
    uint64_t uirr;
    uint64_t uittaddr;
    
}XSaveUINTR;

```



## 栈偏移研究以及反汇编分析

在实现uiret时, 有遇到的问题是, 在恢复上下文以及保存上下文